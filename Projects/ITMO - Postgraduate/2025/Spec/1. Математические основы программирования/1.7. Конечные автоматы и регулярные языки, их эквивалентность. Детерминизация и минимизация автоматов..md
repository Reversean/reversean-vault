# Конечные автоматы и регулярные языки

**[[Конечный автомат]] (КА)** — абстрактная машина, состоящая из конечного числа состояний, предназначенная для распознавания [регулярных языков].

Формальное определение детерминированного конечного автомата (DFA):

$M = (Q, \Sigma, \delta, q_0, F)$

где:

- $Q$ — конечное множество состояний
    
- $\Sigma$ — входной алфавит
    
- $\delta: Q \times \Sigma \to Q$ — функция переходов
    
- $q_0 \in Q$ — начальное состояние
    
- $F \subseteq Q$ — множество принимающих состояний


Автомат принимает слово $w \in \Sigma^*$, если, начиная с q0q_0, по ww он попадает в состояние из FF.

Существует также недетерминированный автомат (NFA), где δ\delta отображает в множество состояний.

---

# Регулярные языки

**Регулярный язык** — это язык, который может быть описан одним из следующих способов:

- [Конечным автоматом]
    
- Регулярным выражением
    
- Регулярной грамматикой
    

Замкнуты относительно операций:

- Объединения: $L_1 \cup L_2$
    
- Конкатенации: $L_1 L_2$
    
- Замыкания Клини: $L^*$
    

Регулярные языки можно распознавать за линейное время от длины входа.

---

# Эквивалентность КА и регулярных языков

Основная теорема:

> Для любого [регулярного языка] существует [конечный автомат], и наоборот — для любого конечного автомата существует регулярное выражение, описывающее распознаваемый им язык.

Это означает, что классы языков, распознаваемые DFA, NFA и описываемые регулярными выражениями — **эквивалентны**.

---

# Детерминизация автоматов

**Детерминизация** — преобразование [недетерминированного конечного автомата (NFA)] в [детерминированный автомат (DFA)].

Метод: **конструкция подмножеств (powerset construction)**

Идея:

- Состояния DFA соответствуют множествам состояний NFA
    
- Переходы определяются по всем возможным входам
    

Сложность: DFA может иметь до 2∣Q∣2^{|Q|} состояний

Детерминизация сохраняет язык: L(NFA)=L(DFA)L(NFA) = L(DFA)

---

# Минимизация автоматов

**Минимизация автомата** — процесс построения [эквивалентного DFA] с наименьшим числом состояний.

Методы:

1. **Алгоритм Хопкрофта** — O(nlog⁡n)O(n \log n)
    
2. **Алгоритм Мура** — итеративное слияние эквивалентных состояний
    

Основная идея:

- Состояния считаются эквивалентными, если их нельзя различить по принимаемым словам
    

Результат:

- Единственный (с точностью до изоморфизма) минимальный DFA, распознающий язык
    

Минимизация важна для:

- Оптимизации памяти и времени
    
- Проверки [эквивалентности автоматов]
    
- Компиляции и анализа регулярных выражений