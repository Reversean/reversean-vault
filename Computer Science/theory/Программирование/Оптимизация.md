Этап [[Компиляция]], на котором [[Промежуточное представление программы]] преобразуются с целью повышения эффективности исполняемого кода без изменения его поведения

Основные цели оптимизации:

- повышение производительности (уменьшение числа инструкций, обращений к памяти)
    
- снижение потребления ресурсов (времени, памяти, энергии)
    
- улучшение параллелизма и использования аппаратных возможностей
    

Оптимизации делятся на:

- **локальные** — внутри [[Базовый блок]]
    
- **глобальные** — на уровне всей функции или модуля
    
- **межпроцедурные** — охватывающие несколько функций
    

Важную роль играют анализы, такие как анализ [[Граф потока управления]] и анализ [[Граф потока данных]], которые позволяют строить модель поведения программы и выявлять возможности для оптимизации

---
### Оптимизации базовых блоков

Типичные оптимизации в пределах одного блока:

- **удаление мёртвого кода** — инструкции, результат которых не используется, удаляются
    
- **свёртка констант** — вычисление выражений на этапе компиляции
    
- **преобразование выражений** — переупорядочивание ассоциативных/коммутативных операций
    
- **снижение количества обращений к памяти** — путём замены на регистровые операции
    
- **общая подвыражение (Common Subexpression Elimination, CSE)** — повторяющиеся выражения вычисляются один раз
    

Оптимизации базовых блоков не требуют знания глобального контекста и являются одними из самых дешёвых по вычислительным затратам

### Чистка циклов

Циклы — важнейшие точки оптимизации, так как в них выполняется большая часть инструкций

Типичные техники:

- **движение инвариантов за пределы цикла** — выражения, не зависящие от переменных цикла, выносятся перед циклом
    
- **разворачивание цикла (loop unrolling)** — уменьшение накладных расходов на проверку условий
    
- **слияние циклов (loop fusion)** — объединение нескольких циклов с одинаковыми границами
    
- **разделение циклов (loop fission)** — разбиение одного цикла на несколько для повышения локальности данных
    
- **удаление мёртвых циклов** — циклы, не влияющие на результат, исключаются
    

Чистка циклов требует анализа зависимостей и использования [[Граф потока управления]]

---

### Распределение регистров

Распределение регистров (register allocation) — процесс сопоставления временных переменных (в IR) с физическими регистрами процессора

Так как число регистров ограничено, компилятор решает, какие переменные держать в регистрах, а какие — сохранять в памяти

Ключевые методы:

- **граф раскраски** — строится интерференционный граф, вершины которого (переменные) получают разные цвета (регистры), если они активны одновременно
    
- **линейный скан (linear scan)** — простой и быстрый алгоритм для JIT-компиляторов
    
- **разлив (spilling)** — если регистров не хватает, часть переменных сохраняется в память
    

Распределение регистров часто выполняется после анализа [[Граф потока управления]] и анализа [[Граф потока данных]] и зависит от того, какие переменные живы в конкретной точке программы

---
