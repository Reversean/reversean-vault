# Алгоритмы на графах

**Граф** — это пара множеств G=(V,E)G = (V, E), где VV — множество вершин, E⊆V×VE \subseteq V \times V — множество рёбер.

Типы графов:

- **Ориентированный** (направленные рёбра)
    
- **Неориентированный** (без направления)
    
- **Взвешенный** (рёбрам приписаны веса)
    
- **Связный**, **ацикличный**, **дерево** и др.
    

Алгоритмы на графах применяются в сетях, ИИ, оптимизации, логистике и др.

---

# Обходы графов

Обход графа — систематический визит всех вершин и/или рёбер графа.

## Поиск в глубину (DFS)

- Стековая рекурсивная стратегия
    
- Используется для:
    
    - Проверки связности
        
    - Поиска компонент сильной связности
        
    - Топологической сортировки
        
- Сложность: O(V+E)O(V + E)
    

## Поиск в ширину (BFS)

- Очередь, уровень за уровнем
    
- Используется для:
    
    - Поиска кратчайшего пути в невзвешенном графе
        
    - Проверки двухцветности
        
- Сложность: O(V+E)O(V + E)
    

---

# Кратчайшие пути

Задача нахождения кратчайшего пути между вершинами по суммарному весу рёбер.

## Алгоритм Дейкстры

- Работает с неотрицательными весами
    
- Использует [очередь с приоритетами]
    
- Сложность: O((V+E)log⁡V)O((V + E) \log V)
    

## Алгоритм Беллмана-Форда

- Поддерживает отрицательные веса
    
- Обнаруживает отрицательные циклы
    
- Сложность: O(VE)O(VE)
    

## Алгоритм Флойда-Уоршелла

- Все пары кратчайших путей
    
- Динамическое программирование
    
- Сложность: O(V3)O(V^3)
    

## Алгоритм A*

- Эвристический поиск с использованием оценки расстояния до цели: f(n)=g(n)+h(n)f(n) = g(n) + h(n)
    
- Где:
    
    - g(n)g(n): стоимость пути от старта до вершины nn
        
    - h(n)h(n): эвристика (например, евклидово расстояние)
        
- Эвристика должна быть допустимой (не переоценивать)
    

---

# Остовные деревья

**Остовное дерево** — подграф, содержащий все вершины и являющийся деревом (то есть связным и ацикличным).

## Минимальное остовное дерево (MST)

- Суммарный вес рёбер минимален
    

### Алгоритм Крускала

- Сортирует рёбра по весу, объединяет компоненты
    
- Использует [систему непересекающихся множеств]
    
- Сложность: O(Elog⁡E)O(E \log E)
    

### Алгоритм Прима

- Строит дерево, начиная с одной вершины, добавляя минимальные рёбра
    
- Сложность: O((V+E)log⁡V)O((V + E) \log V) с очередью с приоритетами
    

---

# Задача о максимальном потоке

**Сетевая модель**: ориентированный граф с источником ss и стоком tt, каждое ребро имеет пропускную способность c(u,v)c(u,v).

Задача: максимизировать поток от ss к tt при соблюдении ограничений:

- 0≤f(u,v)≤c(u,v)0 \leq f(u,v) \leq c(u,v)
    
- Сохранение потока: сумма входов равна сумме выходов, кроме ss и tt
    

## Алгоритмы:

- **Форда-Фалкерсона** — наращивание потока по увеличивающим путям
    
- **Эдмондса-Карпа** — модификация с использованием BFS (O(VE2)O(VE^2))
    
- **Push-Relabel** — эффективен на плотных графах
    

---

# Задача о паросочетании

**Паросочетание** — подмножество рёбер, не имеющее общих вершин.

Варианты:

- Максимальное (по мощности)
    
- Перфектное (все вершины покрыты)
    

Для двудольных графов:

- Алгоритм Хопкрофта-Карпа — O(VE)O(\sqrt{V} E)
    
- Сводится к [максимальному потоку]
    

Применения: задачи распределения, планирования, назначений.

---

# Задача о потоке минимальной стоимости

Обобщение задачи [максимального потока]: каждое ребро имеет стоимость за единицу потока.

Цель: найти допустимый поток максимального значения с минимальной суммарной стоимостью.

Алгоритмы:

- Модификация [алгоритма Форда-Фалкерсона] с потенциалами (например, метод Джонсона)
    
- Алгоритм цикла отрицательной стоимости (min-cost max-flow)
    

Применяется в логистике, экономике, телекоммуникациях.