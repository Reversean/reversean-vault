# Понятие сложности алгоритмов

**Сложность алгоритма** — это характеристика ресурсоёмкости алгоритма, как правило, по времени (временная сложность) или по памяти (пространственная сложность) в зависимости от размера входа nnn.

Типы сложности:

- **Временная сложность**: количество элементарных операций, необходимых для выполнения.
    
- **Пространственная сложность**: объём памяти, используемый алгоритмом.
    

Асимптотические обозначения:

- O(f(n))O(f(n))O(f(n)) — верхняя граница (большое О)
    
- Ω(f(n))\Omega(f(n))Ω(f(n)) — нижняя граница
    
- Θ(f(n))\Theta(f(n))Θ(f(n)) — точная асимптотика
    

Примеры:

- Линейный поиск: O(n)O(n)O(n)
    
- Быстрая сортировка: O(nlog⁡n)O(n \log n)O(nlogn) в среднем
    
- Перебор всех подмножеств: O(2n)O(2^n)O(2n)
    

Сложность используется для классификации в [классы P и NP].

---

# Классы P и NP

**Класс P** — множество задач, которые можно решить на детерминированной [машине Тьюринга] за **полиномиальное время**.

**Класс NP** — множество задач, для которых существует **недетерминированный алгоритм**, решающий задачу за полиномиальное время, или эквивалентно:

> Существует полиномиальный алгоритм, проверяющий корректность **свидетельства** решения.

То есть:

- P⊆NPP \subseteq NPP⊆NP
    
- Неизвестно, равны ли P=NPP = NPP=NP
    

Пример задач из NP:

- [Задача о выполнимости булевой формулы (SAT)]
    
- [Задача о гамильтоновом цикле]
    
- [Задача о рюкзаке]
    

---

# Полиномиальная сводимость задач

Задача AAA **полиномиально сводится** к задаче BBB (A≤PBA \leq_P BA≤P​B), если существует [полиномиальный алгоритм] fff, который преобразует входы из AAA во входы из BBB так, что:

> x∈A  ⟺  f(x)∈Bx \in A \iff f(x) \in Bx∈A⟺f(x)∈B

Сводимость используется для:

- Классификации задач как [NP-полных]
    
- Доказательства [алгоритмической трудности]
    

Если B∈PB \in PB∈P, и A≤PBA \leq_P BA≤P​B, то A∈PA \in PA∈P

---

# Примеры NP-полных задач

Задачи являются **NP-полными**, если:

1. Они принадлежат [NP].
    
2. Любая другая задача из NP полиномиально сводится к ним.
    

Примеры:

- [SAT] (булева выполнимость) — первая доказанная NP-полная задача (теорема Кука, 1971)
    
- [3-SAT] — SAT в КНФ с 3 литералами на дизъюнкт
    
- [Задача о рюкзаке] (Knapsack)
    
- [Задача о гамильтоновом цикле]
    
- [Задача коммивояжёра] (TSP)
    
- [Задача раскраски графа]
    

---

# Приближенные алгоритмы

**Приближённые (аппроксимационные) алгоритмы** — это алгоритмы для задач оптимизации, которые находят **решения, близкие к оптимальным** за полиномиальное время.

Используются для [NP-трудных задач], где точное решение требует экспоненциального времени.

Характеристика: **коэффициент аппроксимации**

r(n)=max⁡(алгоритмическое решениеоптимум,оптимумалгоритмическое решение)r(n) = \max\left(\frac{\text{алгоритмическое решение}}{\text{оптимум}}, \frac{\text{оптимум}}{\text{алгоритмическое решение}}\right)r(n)=max(оптимумалгоритмическое решение​,алгоритмическое решениеоптимум​)

Примеры:

- Жадный алгоритм для [задачи покрытия множества]
    
- 1.51.51.5-приближённый алгоритм для [метрической TSP]
    

---

# Методы решения задач о выполнимости

**Задача о выполнимости (SAT)** — проверить, существует ли такая подстановка переменных в булевой формуле, при которой формула истинна.

Методы решения:

- **Поиск с возвратом (backtracking)**: перебор всех возможных подстановок с отсечением.
    
- **Метод деления и исключения (DPLL)**: добавляет упрощения: unit propagation, pure literal.
    
- **Поисковые методы с обучением (CDCL)**: современное ядро SAT-решателей, использует конфликты и обратный анализ.
    
- **Булевы решатели (SAT-solvers)**: программы, решающие SAT, например MiniSAT, Glucose.
    

Связано с [NP-полными задачами], так как SAT — канонический представитель класса.

---

# Методы решения задач об удовлетворении ограничений

**Задачи об удовлетворении ограничений (CSP — Constraint Satisfaction Problems)** — найти значения переменных, удовлетворяющие заданным ограничениям.

Формально:

> Найти x1,x2,...,xnx_1, x_2, ..., x_nx1​,x2​,...,xn​, такие что для всех ограничений Ci(xi1,...,xik)C_i(x_{i_1}, ..., x_{i_k})Ci​(xi1​​,...,xik​​) выполняется Ci=trueC_i = \text{true}Ci​=true

Примеры: судоку, раскраска графа, планирование.

Методы решения:

- **Поиск в пространстве состояний** (DFS + backtracking)
    
- **Снижение области значений** (arc consistency)
    
- **Локальный поиск** (например, min-conflicts)
    
- Преобразование к [SAT] или [ILP] (целочисленное программирование)
    

CSP — обобщение [SAT].

---

# Эволюционные алгоритмы

**Эволюционные алгоритмы** — класс эвристических методов оптимизации, вдохновлённых принципами биологической эволюции.

Компоненты:

- **Популяция** кандидатов
    
- **Оценка приспособленности** (fitness function)
    
- **Скрещивание** (crossover) и **мутация**
    
- **Отбор** лучших решений
    

Разновидности:

- **Генетические алгоритмы**
    
- **Эволюционные стратегии**
    
- **Генетическое программирование**
    

Применяются к [NP-трудным задачам] и [оптимизационным задачам], где нет точных алгоритмов.