## Конечный автомат

**Конечный автомат** —  абстрактная математическая модель, имеющая один вход, один выход и в каждый момент времени находящегося в одном состоянии из конечного множества возможных.

**Детерминированный конечный автомат** — набор из пяти элементов: 
- $\Sigma$ — алфавит
- $Q$ — множество состояний
- $s \in Q$ — начальное (стартовое) состояние
- $T \subset Q$ — множество допускающих состояний
- $\delta : Q \times \Sigma \rightarrow Q$ — функция переходов

**Недетерминированный конечный автомат (NFA)** отличается тем, что функция перехода может возвращать множество состояний: $\delta: Q \times \Sigma \to 2^Q$.

Изначально автомат находится в стартовом состоянии $s$. Автомат считывает символы по очереди. При считывании очередного символа $p_i$ автомат переходит в состояние $\delta (q,p_i)$, где $q$ — текущее состояние автомата. Процесс продолжается до тех пор, пока не будет достигнут конец входного слова.

## Регулярные языки

**Регулярный язык** в алфавите $\Sigma = \{c_1, c_2, ..., c_k\}$ называется множеством языков, которое можно получить из языков:

- пустого языка $\emptyset$
- состоящих из пустой строки $\varepsilon$
- состоящих из единственного слова $c_i$
- объединения регулярных языков $L_1 \cup L_2$
- конкатенации регулярных языков $L_1 \cdot L_2$
- замыканием Клини регулярного языка $L^*$

Согласно теореме Клини можно доказать, что класс регулярных языков является подмножеством класса автоматных языков, а класс автоматных языков является подмножеством регулярных языков. Таким образом можно заключить, что классы автоматных и регулярных языков совпадают.

## Детерминизация автоматов 

Процесс детерминизации переводит NFA в эквивалентный DFA.

### Алгоритм subset construction (построение множества состояний)

Алгоритм детерминизации, также известный как алгоритм построения множества состояний, превращает NFA в эквивалентный DFA. Основные шаги алгоритма следующие:

1. Инициализация
	
	- Начните с начального состояния NFA. Это состояние в DFA будет представлять множество состояний NFA, в которые можно попасть из начального состояния с помощью ε-переходов. Обозначим это множество как ϵ\epsilonϵ-замыкание начального состояния NFA.
	
3. Создание начального состояния DFA
	
	- Создайте начальное состояние DFA, которое будет соответствовать множеству состояний NFA, полученное в результате ε-замыкания начального состояния NFA.
	
3. Построение состояний DFA
	
	- Для каждого состояния DFA (каждое состояние DFA — это множество состояний NFA):
	    - Для каждого символа входного алфавита:
	        - Определите множество состояний NFA, в которые можно попасть из состояний в текущем множестве с помощью данного символа. Это множество будет новым состоянием DFA.
	        - Если это новое состояние DFA еще не создано, создайте его и добавьте в список состояний DFA.
	
4. Создание переходов DFA
	
	- Для каждого состояния DFA и для каждого символа входного алфавита определите переходы между состояниями DFA, как описано выше.
	
5. Определение принимающих состояний
	
	- Состояние DFA считается принимающим, если оно содержит хотя бы одно принимающее состояние из NFA.
	
6. Завершение
	
	- Продолжайте процесс до тех пор, пока все возможные состояния DFA не будут созданы и обработаны.
	

## Минимизация автоматов

Процесс минимизации DFA заключается в нахождении эквивалентного DFA с минимальным числом состояний, но сохраняет ту же самую функцию переходов и распознавания языка. Минимизация помогает упростить автомат, сделать его более эффективным для реализации и анализа.

Основные шаги минимизации конечных автоматов:

1. Удаление недостижимых состояний
	
	- Первый шаг в минимизации — удалить все состояния, которые недостижимы из начального состояния. Это достигается следующим образом:
		- **Инициализация**: Начните с начального состояния и отметьте его как достижимое.
		- **Обход**: Используйте алгоритм поиска в ширину или глубину, чтобы пройти по всем достижимым состояниям, отмечая их как достижимые.
		- **Удаление**: Удалите все состояния, которые не были отмечены как достижимые.
	
 2. Слияние эквивалентных состояний
	 
	- После удаления недостижимых состояний, следующий шаг — определить эквивалентные состояния и объединить их.
		- **Инициализация**: Разделите состояния на две группы: принимающие и не принимающие.
		- **Разделение**: Продолжайте разделять группы на подгруппы до тех пор, пока все состояния в группе не будут идентичными по своим переходам для каждого символа входного алфавита. Состояния считаются эквивалентными, если для каждого символа входного алфавита они переходят в одно и то же состояние.
	
