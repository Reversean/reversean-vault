Парадигма разработки, в которой процесс вычисления представлен как вычисление [[функций]] (имеются в виду математические).

Относится к парадигмам [[Декларативное программирование]].

Ключевые концепции:

- **[[Чистая функция|чистые функции]]** — результат зависит только от входных аргументов, отсутствие изменений внешнего состояния  
- **неизменяемость** — данные не изменяются, создаются новые версии при «модификации»  
- **функции высшего класса** — функции передаются как аргументы, возвращаются из других функций и сохраняются в структурах данных  
- **рекурсия** — основной способ организации итеративных вычислений вместо циклов
- **ленивые вычисления** — отложенный расчёт значений до их использования  
- **референциальная прозрачность** — возможность заменять вызов функции её значением без изменения поведения программы  

---
## Подходы к проектированию и реализации

При проектировании функциональных систем учитываются особенности языков и сред:

- **выбор модели вычислений**: жадная (eager) или ленивость (lazy evaluation)  
- **типизация**: статическая (Haskell, OCaml) или динамическая (Clojure, Elixir)  
- **сопровождение побочных эффектов**: монады (IO, State), эффекты (algebraic effects)  
- **оптимизации**: каррирование (currying), частичное применение, дефорестация (deforestation), fusion-трансформации  
- **паттерны**: рекурсивные модули, монады и моноиды, композиция монад (monad transformers)  
- **улучшение производительности**: хвостовая рекурсия, сопоставление с образцом (pattern matching), оптимизации на уровне компилятора  
- **инструменты**: компиляторы (GHC, OCamlopt), JIT-сборщики (BEAM для Elixir/Erlang), библиотеки (Prelude, fp-ts)  

